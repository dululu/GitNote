<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/dululu/GitNote</id><title>RSS feed of dululu's GitNote</title><updated>2024-07-31T17:19:57.217451+00:00</updated><link href="https://github.com/dululu/GitNote"/><link href="https://raw.githubusercontent.com/dululu/GitNote/main/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/dululu/GitNote/issues/66</id><title>Command line in Linux</title><updated>2024-07-31T17:19:57.707593+00:00</updated><content type="html"><![CDATA[<h2>A</h2>
<p><code>ls</code>
<code>cp</code>
<code>mv</code>
<code>rm</code>
<code>mkdir</code>
<code>cd</code>
<code>rmdir</code>
<code>clear</code></p>
<img width="487" alt="image" src="https://github.com/user-attachments/assets/4887a5a6-fcb2-4a4f-9ecf-5dd875d2970e">
]]></content><link href="https://github.com/dululu/GitNote/issues/66"/><category term="工具使用"/><published>2024-07-31T15:10:42+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/65</id><title>环境变量</title><updated>2024-07-31T17:19:57.796774+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>pyhon</p>
</blockquote>
<ul>
<li>
<p>打开环境变量
快捷键：win+R “sysdm.cpl”
或者右键文件资源管理器</p>
</li>
<li>
<p>编辑用户变量
找到<code>path</code>
<img width="417" alt="image" src="https://github.com/user-attachments/assets/11fc0378-cfed-4af6-8546-2d62bbaf3537"></p>
</li>
<li>
<p>有两个版本的python
那个在上面系统就默认调用那个版本的python</p>
</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/65"/><category term="工具使用"/><published>2024-07-23T01:26:10+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/64</id><title>Nginx 和 Tomcat</title><updated>2024-07-31T17:19:57.921575+00:00</updated><content type="html"><![CDATA[<ul>
<li>Flask是一个使用Python编写的轻量级Web应用框架。</li>
<li>RESTful（Representational State Transfer）是一种设计和组织Web服务的架构风格，用于构建可伸缩、可维护和可扩展的网络应用程序。</li>
</ul>
<h2>Nginx 和 Tomcat</h2>
<p>Nginx和Tomcat是两个常用的网络服务器软件，常用于构建和托管Web应用程序。虽然它们都可以用作Web服务器，但它们在功能和用途上有一些区别。</p>
<p>Nginx（发音为&quot;engine-x&quot;）是一个高性能的开源Web服务器，也可以用作反向代理服务器、负载均衡器和HTTP缓存服务器。Nginx以其出色的性能和可靠性而闻名，特别适用于高并发的Web应用场景。它采用事件驱动的异步架构，能够有效地处理大量的并发连接。Nginx还具有灵活的配置选项和强大的URL重写功能，可以实现灵活的代理和路由规则。</p>
<p>Tomcat是一个开源的Java Servlet容器和JSP引擎，它提供了一个Java运行环境，用于执行Java Servlet和JavaServer Pages（JSP）。Tomcat是Apache软件基金会的一个项目，被广泛用于托管Java Web应用程序。它提供了一个容器，可以解释和执行Servlet和JSP代码，并将动态内容生成为静态的HTML页面，然后由Web服务器（如Nginx）提供给客户端。</p>
<p>在实际应用中，通常会将Nginx作为前端服务器，用于处理静态资源的请求、负载均衡和反向代理。Nginx可以接收客户端的请求，并根据配置将请求转发到后端的Tomcat服务器。Tomcat则专注于处理动态内容，如Java Servlet和JSP，它可以与Nginx配合使用，提供完整的Web应用程序服务。</p>
<p>通过将Nginx与Tomcat结合使用，可以充分发挥它们各自的优势。Nginx作为反向代理和负载均衡器可以提供高性能和可靠性，而Tomcat作为Java应用程序容器可以处理动态内容和提供Java相关的功能。</p>
<p>总结起来，Nginx和Tomcat在Web服务器领域扮演不同的角色。Nginx适用于高性能的静态资源服务、反向代理和负载均衡，而Tomcat则专注于托管和执行Java Servlet和JSP的动态内容。结合使用它们可以构建强大而可靠的Web应用程序架构。</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/64"/><category term="工具使用"/><published>2024-06-12T09:45:49+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/63</id><title>`sudo apt-get update`</title><updated>2024-07-31T17:19:58.045089+00:00</updated><content type="html"><![CDATA[<h2>刺探最新的情报</h2>
<blockquote>
<p><code>sudo apt-get update</code> 是在<code>Ubuntu</code>或<code>Debian</code>系统中使用的命令，用于更新<strong>软件包列表</strong>和<strong>软件包管理器</strong>的元数据。让我们逐个解释每个部分的含义</p>
</blockquote>
<ul>
<li><code>sudo</code>: sudo是一个用于以超级用户（<code>root</code>）权限执行命令的命令。在执行需要管理员权限的操作时，需要使用 <code>sudo</code>。它会要求您输入当前用户的密码，以确认您具有足够的权限来执行该命令。</li>
<li><code>apt-get</code>: apt-get 是Ubuntu和Debian等Linux发行版中的包管理器命令。它用于安装、升级和删除软件包，以及管理软件包的依赖关系。</li>
<li><code>update</code>: update 是 apt-get 命令的一个操作选项，用于更新软件包列表和软件包管理器的元数据。它会与软件源（包含软件包的服务器）通信，并检查可用的更新。这样，您可以获取到最新的软件包和版本信息。</li>
</ul>
<p>综上所述，<code>sudo apt-get update</code> 命令的目的是<strong>更新您系统中可用的软件包列表</strong>和<strong>软件包管理器的元数据</strong>。这是在安装新软件包或升级现有软件包之前的一项重要步骤，以确保您<strong>使用的是最新的软件包信息</strong>。</p>
<hr />
<h3>包管理</h3>
<p>python: <code>pip install pg</code>
nodejs: <code>npm install pg</code>
Ubuntu: <code>apt-get install pg</code></p>
]]></content><link href="https://github.com/dululu/GitNote/issues/63"/><category term="问题记录"/><published>2024-06-07T17:20:51+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/62</id><title>Docker</title><updated>2024-07-31T17:19:58.156315+00:00</updated><content type="html"><![CDATA[<blockquote>
<p><code>Docker</code>是一种开源的容器化平台，它可以帮助开发者<strong>构建、打包、部署和运行</strong>应用程序。通过使用<code>Docker</code>，开发者可以将<strong>应用程序及其所有依赖项打包</strong>到一个称为&quot;容器&quot;的独立运行环境中，然后在不同的环境中进行<strong>部署</strong>，而无需担心环境差异和依赖关系的问题。</p>
</blockquote>
<h3>以下是关于Docker的一些重要信息：</h3>
<ul>
<li><strong>容器化技术</strong>：Docker基于容器化技术，容器是一种轻量级、可移植的虚拟化技术。它通过利用操作系统级别的虚拟化来隔离应用程序及其依赖项，并提供<strong>一致的运行环境</strong>。</li>
<li><strong>镜像和容器：<strong>Docker使用镜像作为构建和分发应用程序的</strong>基本单元</strong>。镜像是一个<strong>只读</strong>的模板，包含了运行应用程序所需的所有文件和设置。通过镜像，可以创建运行时的容器实例。容器是镜像的可运行实例，它可以被启动、停止、删除和管理。</li>
<li><strong>跨平台和可移植性</strong>：Docker提供了跨平台的支持，可以在各种操作系统（如Linux、Windows、macOS等）上运行。容器化的应用程序具有高度的可移植性，可以在不同的环境中以相同的方式运行，减少了因环境差异而导致的问题。</li>
<li><strong>管理工具和生态系统</strong>：Docker提供了一系列管理工具，如Docker CLI、Docker Compose和Docker Swarm，用于构建、管理和编排容器。此外，Docker生态系统中有大量的公共镜像和社区贡献的工具，可以方便地共享和使用。</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/62"/><category term="工具使用"/><published>2024-06-07T15:45:48+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/61</id><title>npm</title><updated>2024-07-31T17:19:58.291649+00:00</updated><content type="html"><![CDATA[<h2>npm</h2>
<blockquote>
<p>介绍：npm（Node Package Manager）是Node.js的<strong>包管理器</strong>，用于安装、更新和管理JavaScript模块。它是Node.js生态系统中最常用的工具之一，许多开发者使用它来管理他们的项目依赖项。</p>
</blockquote>
<h4>常见用法：</h4>
<ul>
<li>安装npm：当您安装Node.js时，npm会自动安装在您的计算机上，您可以通过在终端或命令提示符中运行<code>npm -v</code>来<strong>验证</strong>它是否已安装。</li>
<li>初始化项目：在开始一个新的项目时，您可以使用<code>npm init</code>命令来<strong>初始化</strong>项目并生成一个<code>package.json</code>文件。package.json文件包含了项目的<strong>元数据和依赖项信息</strong></li>
<li>安装依赖项：使用<code>npm install</code>命令可以安装项目所需的依赖项。您可以在命令后面指定要安装的包的名称，也可以通过在package.json文件中列出依赖项并运行npm install来安装所有依赖项。</li>
</ul>
<pre><code>npm install package-name
npm install --save package-name
npm install --save-dev package-name
npm install
</code></pre>
<p><code>--save</code>标志用于将包<strong>添加到<code>package.json</code>文件</strong>的dependencies部分，<code>--save-dev</code>标志用于将包<strong>添加到devDependencies部分。</strong></p>
<ul>
<li>升级依赖项：使用<code>npm update</code>命令可以升级项目的依赖项。它会检查安装的包的最新版本，并更新<code>package.json</code>文件中的版本号。 例如：</li>
</ul>
<pre><code>npm update package-name
npm update 
</code></pre>
<ul>
<li>全局安装：除了项目依赖项外，npm还支持<strong>全局安装包</strong>。<strong>全局安装的包可以在命令行中</strong>直接访问。要全局安装一个包，您可以使用<code>-g</code>标志。 例如：</li>
</ul>
<pre><code>npm uninstall package-name
npm install -g package-name
</code></pre>
]]></content><link href="https://github.com/dululu/GitNote/issues/61"/><category term="工具使用"/><published>2024-06-07T14:54:40+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/58</id><title>RPC failed</title><updated>2024-07-31T17:19:58.416710+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>错误描述:<code>error: RPC failed; curl 52 OpenSSL SSL_read: Connection was reset, errno 10054 fatal: the remote end hung up unexpectedly</code></p>
</blockquote>
<h3>这个错误消息的主要组成部分是：</h3>
<ul>
<li>
<ol>
<li><code>&quot;error: RPC failed&quot;：RPC（Remote Procedure Call）</code>表示远程过程调用，这里指的是<code> Git</code> 在与远程服务器通信时发生了错误。</li>
</ol>
</li>
<li>
<ol start="2">
<li>&quot;curl 52 OpenSSL SSL_read: Connection was reset, errno 10054&quot;：这部分错误消息指示在使用 curl 进行网络请求时发生了连接重置错误。</li>
</ol>
</li>
<li>
<p>3.<code> &quot;fatal: the remote end hung up unexpectedly&quot;</code>：这是<code> Git</code> 给出的致命错误消息，表示远程服务器意外地关闭了连接。</p>
</li>
</ul>
<h4>根据这个错误消息，可能存在以下原因和解决方案：</h4>
<ol>
<li>
<p>网络连接问题：这个错误可能是由于网络连接不稳定、网络故障或防火墙设置等问题引起的。确保你的网络连接正常，并尝试通过使用其他网络或连接 VPN 来解决问题。</p>
</li>
<li>
<p>远程服务器问题：有时候远程服务器本身可能存在问题，导致连接中断。可以尝试访问远程仓库的网页界面，查看是否存在任何通知或问题报告。</p>
</li>
<li>
<p>代理服务器问题：如果你使用了代理服务器，可能需要检查代理服务器的设置是否正确，并确保它不会阻止 Git 的网络请求。</p>
</li>
<li>
<p>缓冲区大小限制：较小的缓冲区大小可能会导致连接问题。尝试增加 Git 的缓冲区大小，可以通过运行 <code>git config --global http.postBuffer 524288000</code> 命令将缓冲区大小设置为 500MB。</p>
</li>
<li>
<p>使用 SSH 替代 HTTPS：如果你使用的是 HTTPS 进行远程操作，尝试将远程仓库的 URL 更改为 SSH 格式，可能会解决某些连接问题。</p>
</li>
</ol>
<p>如果上述解决方案都无法解决问题，建议稍后再次尝试或联系远程服务器的管理员以获得更多帮助。</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/58"/><category term="问题记录"/><published>2024-06-01T00:44:25+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/55</id><title>关于星座，属相，16型人格，血型的一点点看法</title><updated>2024-07-31T17:19:58.518892+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>先说一下我的刻板印象</p>
</blockquote>
<ul>
<li>星座：初中时很火，因为写了很多同学录，我觉得只是众多被创造的<code>标签</code>之一，可信度很低。</li>
<li>属相：老祖宗的东西，老黄历，很迷，没有现实依据，很难让人信服。</li>
<li>16型人格：最近几年的网红标签，与心理学社会学有一些关联，觉得世界上因该没有大一统的公式，各种代码也不能科学的描述一个人，感觉许多人是在往里钻，有点画地为牢了，可以借鉴一下，分析人的方法，但人终究是复杂多变的，理论有一点形而上学了。</li>
<li>血型：人类万年的进化，个体之间存在的差异应该很小了，后天取得的成就很难用血型去解释，但差异应该还是有的，一小部分罢了，因为人类还在一直进化。</li>
</ul>
<h2>了解才能选择</h2>
<h3>没有调查就没有发言权</h3>
<ul>
<li><a href="https://www.bilibili.com/read/cv6647556/?spm_id_from=333.999.collection.opus.click">https://www.bilibili.com/read/cv6647556/?spm_id_from=333.999.collection.opus.click</a></li>
</ul>
<p>想到了再写</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/55"/><category term="日记"/><published>2024-06-01T00:15:29+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/54</id><title>About me</title><updated>2024-07-31T17:19:58.623771+00:00</updated><content type="html"><![CDATA[<ul>
<li><a href="https://www.yangtzeu.edu.cn/xxgk.htm">YU</a></li>
<li>Love Python</li>
<li><a href="https://dululu.github.io/">Always on the way</a></li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/54"/><published>2024-06-01T00:06:44+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/53</id><title>流畅的Python</title><updated>2024-07-31T17:19:58.819846+00:00</updated><content type="html"><![CDATA[<h2>传送门👇</h2>
<p><a href="https://github.com/dululu/obsgit/tree/main/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B5%81%E7%95%85%E7%9A%84python">🍺🍺🍺</a></p>
]]></content><link href="https://github.com/dululu/GitNote/issues/53"/><category term="读书笔记"/><published>2024-05-31T23:17:29+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/43</id><title>unittest单元测试</title><updated>2024-07-31T17:19:58.931332+00:00</updated><content type="html"><![CDATA[<p><a href="https://docs.python.org/3/library/unittest.html">https://docs.python.org/3/library/unittest.html</a></p>
<h3>文件结构</h3>
<img width="122" alt="image" src="https://github.com/dululu/notes/assets/64392262/56d6a8f6-480d-4373-bdaa-8f277bf58e52">
<p>把<code>vector</code>文件夹变成一个<code>package</code>
<img width="121" alt="image" src="https://github.com/dululu/notes/assets/64392262/2cc1a2d9-9164-4c80-863e-f751845bb68c">
根目录下创建<code>tests</code>文件夹，放测试文件，变成一个<code>package</code></p>
<h4><code>unittest</code> Python自带测试框架</h4>
<pre><code>python -m unittest   //根目录下运行，自动运行测试
</code></pre>
<h3>写测试</h3>
<ul>
<li>每一个测试文件必须要是以<code>test_</code>开头</li>
</ul>
<pre><code>import unittest

# 要测试的函数
def add_numbers(a, b):
    return a + b

# 编写测试用例
class TestAddNumbers(unittest.TestCase):
    def test_add_numbers(self):
        result = add_numbers(3, 5)
        self.assertEqual(result, 8)  # 断言结果等于 8

        result = add_numbers(-2, 2)
        self.assertEqual(result, 0)  # 断言结果等于 0

        result = add_numbers(10, -7)
        self.assertEqual(result, 3)  # 断言结果等于 3

# 运行测试
if __name__ == &#x27;__main__&#x27;:
    unittest.main()
</code></pre>
<ul>
<li>继承<code> unittest.TestCase</code> 的测试类</li>
<li><code>test method</code>必须以<code>test_</code>开头</li>
</ul>
<h3>常用<code>feature</code></h3>
]]></content><link href="https://github.com/dululu/GitNote/issues/43"/><category term="Python"/><published>2024-04-08T20:11:53+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/41</id><title>Django</title><updated>2024-07-31T17:19:59.038024+00:00</updated><content type="html"><![CDATA[<h2>Django<a href="https://github.com/jaywcjlove/reference/blob/main/docs/django.md">&lt;_&gt;</a></h2>
<h2>M models
T templates
V views
MTV</h2>
<h3>环境配置</h3>
<ul>
<li>安装<code>Django</code></li>
</ul>
<pre><code class="language-python">pip3.10 install django    // 最好指定Python的版本
</code></pre>
<p>需要将<code>Python</code>加入环境变量path中
在终端中输入<code>django-admin</code>,出现提示即可</p>
<h2>创建项目</h2>
<blockquote>
<p>django-admin startproject  su7</p>
</blockquote>
<ul>
<li>项目文件目录</li>
<li>App</li>
</ul>
<blockquote>
<p><strong>创建app:</strong> python manage.py startapp app01</p>
</blockquote>
<p><strong>所以最终一共有两个主要的文件目录：一个是默认的文件，一个是项目生成时创建的文件。</strong>
<img width="326" alt="image" src="https://github.com/dululu/notes/assets/64392262/ea5d9ce5-38b6-43fc-ae3e-79e3f43b4509"></p>
<h2>启动运行Django</h2>
<pre><code class="language-python">python manage.py runserver
</code></pre>
<img width="388" alt="image" src="https://github.com/dululu/notes/assets/64392262/ab693d14-023f-40eb-a52d-75279f44892d">
<h5>名为 <code>views.py</code> 的文件。这是我们<strong>收集发送回正确响应所需的信息的地方</strong>。</h5>
<ul>
<li><code>Django</code> 接收 <code>URL</code>，检查 <code>urls.py</code> 文件，并调用与 <code>URL</code> 匹配的视图。</li>
<li>位于 <code>views.py</code> 中的视图检查相关模型。</li>
<li>模型是从 <code>models.py</code> 文件中导入的。</li>
<li>然后视图将数据发送到模板文件夹中的指定模板。</li>
<li>模板包含 <code>HTML</code> 和 <code>Django</code> 标记，并使用数据将完成的 <code>HTML</code> 内容返回给浏览器</li>
</ul>
<h3><strong>启动<code>Django</code>-&gt;<code>Django</code>检查<code>url.py</code>文件-&gt;调用与<code>URL</code>匹配的示图</strong></h3>
<h2><strong>关于根路由</strong></h2>
<p>在与 <code>views.py</code> 文件相同的文件夹中创建一个名为 <code>urls.py</code> 的文件，并在其中输入以下代码：</p>
<pre><code class="language-python">from django.urls import path
from . import views
urlpatterns = [
    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),
]
</code></pre>
<p>在 根路由<code>import</code>语句中添加 <code>include</code> 模块，并在列表中添加一个 <code>path()</code> 函数。文件将如下所示：</p>
<pre><code class="language-python">from django.contrib import admin
from django.urls import include, path

urlpatterns = [
  path(&#x27;members/&#x27;, include(&#x27;members.urls&#x27;)),  # 这里的是App的名称
  path(&#x27;admin/&#x27;, admin.site.urls),
]
</code></pre>
<p><code>Django</code> 视图是接受 <code>http</code> 请求并返回 <code>http</code> 响应的 <code>Python</code> 函数</p>
<pre><code class="language-python">from django.shortcuts import render
from django.http import HttpResponse

def index(request):
    return HttpResponse(&quot;Hello world!&quot;)
</code></pre>
<p>再次运行<code>Django</code>时就可以返回来自客户端的回应</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/41"/><category term="Python"/><published>2024-03-30T18:06:26+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/39</id><title>字符串格式化</title><updated>2024-07-31T17:19:59.268751+00:00</updated><content type="html"><![CDATA[<h2><a href="https://pyformat.info/">字符串格式化</a></h2>
]]></content><link href="https://github.com/dululu/GitNote/issues/39"/><category term="Python"/><published>2024-03-30T17:52:51+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/38</id><title> urllib3</title><updated>2024-07-31T17:19:59.384453+00:00</updated><content type="html"><![CDATA[<p><code>urllib3</code>是一个<code>Python</code>的第三方库，用于在<code>HTTP</code>请求中处理连接池、编码、重试等功能。它提供了一个高级的<code>HTTP</code>客户端接口，简化了与Web服务器进行通信的过程。</p>
<ul>
<li>使用<code>urllib3</code>库可以进行<code>HTTP</code>请求的发送和处理。可以创建<code>PoolManager</code>对象来管理连接池，并使用该对象发送<code>GET</code>、<code>POST</code>等类型的请求。<code>urllib3</code>提供了对请求和响应的各种处理方法，例如设置请求头部、处理响应内容等。</li>
</ul>
<h5>以下是一个使用urllib3发送GET请求的简单示例：</h5>
<pre><code class="language-python">import urllib3
# 创建连接池管理器
http = urllib3.PoolManager()
# 发送GET请求
response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;)
# 获取响应内容
data = response.data
# 打印响应内容
print(data.decode(&#x27;utf-8&#x27;))
</code></pre>
<blockquote>
<p>首先创建了一个<code>PoolManager</code>对象，然后使用该对象发送<code>GET</code>请求，请求的目标<code>URL</code>是<code>http://www.example.com</code>。最后，通过<code>response.data</code>获取响应的内容，并将其解码为字符串后打印出来。</p>
</blockquote>
<h4>HEAD请求和GET请求在HTTP协议中是两种不同的请求方法，</h4>
<ul>
<li>返回内容：<code>GET</code>请求会返回请求的资源内容，包括响应头部和响应体。而<code>HEAD</code>请求只返回响应头部，不返回响应体内容。因此，HEAD请求可以用于仅获取资源的元数据或检查资源是否存在，而不需要获取实际内容。</li>
</ul>
<hr />
<h3>更灵活地处理请求和响应。</h3>
<ul>
<li><strong>自定义请求头部</strong>：您可以通过在请求时传递headers参数来设置自定义的请求头部。例如：</li>
</ul>
<pre><code class="language-python">headers = {
    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;,
    &#x27;Authorization&#x27;: &#x27;Bearer your_token_here&#x27;
}
response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;, headers=headers)
</code></pre>
<p>在上面的示例中，我们定义了一个<strong>字典</strong><code>headers</code>，包含了自定义的请求头部信息，并将其作为<code>headers</code>参数传递给请求方法。</p>
<ul>
<li><strong>处理请求参数</strong>：如果需要在GET请求中传递查询参数，可以<strong>使用fields参数将参数以字典形式传递给请求方法</strong>。例如：</li>
</ul>
<pre><code class="language-python">params = {
    &#x27;key1&#x27;: &#x27;value1&#x27;,
    &#x27;key2&#x27;: &#x27;value2&#x27;
}
response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;, fields=params)
</code></pre>
<p>在上面的示例中，我们定义了一个字典<code>params</code>，包含了查询参数的键值对，并将其作为<code>fields</code>参数传递给GET请求方法。</p>
<ul>
<li><strong>处理POST请求数据</strong>：对于POST请求，可以使用<code>body</code>参数或<code>fields</code>参数来传递请求数据。如果需要<strong>发送<code>JSON</code>格式的数据</strong>，可以使用<code>json</code>参数。例如：</li>
</ul>
<pre><code class="language-python">import json

data = {
    &#x27;name&#x27;: &#x27;John Doe&#x27;,
    &#x27;age&#x27;: 30
}
encoded_data = json.dumps(data).encode(&#x27;utf-8&#x27;)

response = http.request(&#x27;POST&#x27;, &#x27;http://www.example.com&#x27;, body=encoded_data, headers={&#x27;Content-Type&#x27;: &#x27;application/json&#x27;})
</code></pre>
<p>在上面的示例中，我们将数据编码为<code>JSON</code>格式并将其作为body参数传递给<code>POST</code>请求方法。还设置了请求头部中的<code>Content-Type为application/json</code>，指示服务器接收<code>JSON</code>格式的数据。</p>
<ul>
<li><strong>处理响应</strong>：<code>urllib3</code>的响应对象提供了许多属性和方法来处理响应数据。例如，可以使用<code>response.status</code>获取响应的状态码，<code>response.headers</code>获取响应头部信息，<code>response.data</code>获取响应的内容等。</li>
</ul>
<pre><code class="language-python">response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;)
status_code = response.status
headers = response.headers
data = response.data
</code></pre>
]]></content><link href="https://github.com/dululu/GitNote/issues/38"/><category term="Python"/><published>2024-03-30T06:13:17+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/37</id><title> HTTP/1.1 </title><updated>2024-07-31T17:19:59.509412+00:00</updated><content type="html"><![CDATA[<p>当客户端使用HTTP/1.1与服务器进行通信时，以下是一个简单的示例：</p>
<pre><code>GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: text/html,application/xhtml+xml
</code></pre>
<p><strong>客户端</strong>发送一个<code>GET</code>请求，请求获取位于<strong>服务器</strong>上的index.html文件。请求中使用了<strong>HTTP/1.1</strong>版本。
请求头部包含了一些额外的信息：</p>
<ul>
<li><code>Host</code>头部指定了<strong>服务器</strong>的域名（[www.example.com），这是HTTP/1.1中引入的一个必需的头部。</li>
<li><code>User-Agent</code>头部指定了<strong>客户端的用户代理</strong>，即浏览器的身份信息。</li>
<li><code>Accept</code>头部指定了<strong>客户端</strong>可以接受的响应内容类型，这里指定可以接受<code>HTML</code>和<code>XHTML</code>类型的内容。</li>
</ul>
<hr />
<h4>当客户端使用HTTP/1.1进行<code>POST</code>请求时，以下是一个简单的示例：</h4>
<pre><code>POST /submit-form HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25

username=johndoe&amp;password=123
</code></pre>
<p><strong>客户端</strong>发送了一个<code>POST</code>请求，将表单数据提交到服务器上的<code>/submit-form</code>路径。</p>
<blockquote>
<p>与GET请求相比，<code>POST</code>请求通常用于向服务器提交数据，如表单数据。</p>
</blockquote>
<p>请求头部包含了一些额外的信息：</p>
<ul>
<li><code>Host</code>头部指定了服务器的域名</li>
<li><code>Content-Type</code>头部指定了请求体的媒体类型为<code>application/x-www-form-urlencoded</code>，表示表单数据将使用<code>URL</code>编码格式进行传输。</li>
<li><code>Content-Length</code>头部指定了请求体的长度，这里是25个字节。</li>
</ul>
<h2>POST请求和GET请求是HTTP协议中两种常见的请求方法，它们在以下几个方面有着明显的区别：</h2>
<ul>
<li>数据传输位置：GET请求通过URL的查询参数将数据<strong>附加在请求URL的末尾，而POST请求将数据包含在请求的主体中</strong>。因此，GET请求的数据在URL中是可见的，而POST请求的数据对于普通用户来说是不可见的。</li>
<li>安全性：由于GET请求将数据<strong>暴露在URL</strong>中，数据容易被拦截、篡改或缓存。相比之下，POST请求将数据放在请求主体中，对于一些敏感信息（如密码）的传输更为安全。</li>
<li>数据长度限制：GET请求的<strong>数据传输受到URL长度限制的影响</strong>，不同的浏览器和服务器有不同的限制值，通常在几千个字符左右。而POST请求的数据传输没有固定的长度限制，但服务器和应用程序可能会设置自己的限制。</li>
<li>数据类型：G<strong>ET请求通常用于获取资源或从服务器获取数据，而POST请求通常用于向服务器提交数据</strong>，例如表单提交、文件上传等。POST请求允许发送更多类型的数据，而GET请求主要适用于发送简单的键值对数据。</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/37"/><category term="Python"/><published>2024-03-30T05:30:25+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/36</id><title>Requests HTTP for Humans</title><updated>2024-07-31T17:19:59.615472+00:00</updated><content type="html"><![CDATA[<h2><a href="https://requests.readthedocs.io/en/latest/">Requests</a></h2>
<ul>
<li><a href="https://github.com/dululu/notes/issues/37">HTTP/1.1</a></li>
<li><a href="https://github.com/dululu/notes/issues/38">urllib3</a></li>
<li><a href="https://github.com/dululu/notes/issues/38">JSON</a></li>
<li><a href="https://github.com/dululu/notes/issues/34">Status Codes¶</a></li>
<li>SSL Cert Verification</li>
</ul>
<hr />
<h3>Quickstart<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#quickstart">¶</a></h3>
<ul>
<li>Response Content</li>
<li>Binary Response Content</li>
<li>JSON Response Content</li>
<li>Custom Headers</li>
<li>More complicated POST requests<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#more-complicated-post-requests">¶</a></li>
<li>POST a Multipart-Encoded File<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#post-a-multipart-encoded-file">¶</a></li>
<li>Response Status Codes<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#response-status-codes">¶</a></li>
<li>Response Headers<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#response-headers">¶</a>
We can view the server’s response headers using a Python dictionary:
<strong>HTTP Header names are case-insensitive.</strong> </li>
</ul>
<pre><code class="language-python">import requests
r = requests.get(&#x27;https://httpbin.org/get&#x27;)
r.status_code
print(r.status_code)
print(r.headers)

r.headers[&#x27;Content-Type&#x27;]
&#x27;application/json&#x27;

r.headers.get(&#x27;content-type&#x27;)
&#x27;application/json&#x27;
</code></pre>
<ul>
<li>Cookies<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#cookies">¶</a>
If a response contains some Cookies, you can quickly access them,Cookies are returned in a <a href="https://requests.readthedocs.io/en/latest/api/#requests.cookies.RequestsCookieJar">RequestsCookieJar</a>, which acts like a dict but also offers a more complete interface, suitable for use over multiple domains or paths. Cookie jars can also be passed in to requests:</li>
<li>Redirection and History<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#redirection-and-history">¶</a></li>
<li>Timeouts<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#timeouts">¶</a>
You can tell Requests to stop waiting for a response after a given number of seconds with the <code>timeout</code> parameter.</li>
<li>Errors and Exceptions<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#errors-and-exceptions">¶</a></li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/36"/><category term="Python"/><published>2024-03-30T05:05:15+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/34</id><title>Status Codes¶</title><updated>2024-07-31T17:19:59.725468+00:00</updated><content type="html"><![CDATA[<p>HTTP状态码（Status Codes）是在HTTP协议中用于表示请求的处理结果的三位数代码。每个状态码都具有特定的含义，用于指示请求是否成功、遇到错误、需要进一步操作等。
以下是一些常见的HTTP状态码及其含义：</p>
<ul>
<li>200 OK：请求成功。服务器成功处理了请求并返回所需的内容。</li>
<li>201 Created：已创建。请求成功，并在服务器上创建了新的资源。</li>
<li>204 No Content：无内容。请求成功，但响应不包含任何内容。</li>
<li>400 Bad Request：错误的请求。服务器无法理解或处理请求，通常是由于请求语法错误。</li>
<li>401 Unauthorized：未授权。请求需要身份验证，但未提供有效的身份凭据。</li>
<li><code>403 Forbidden</code>：禁止访问。服务器拒绝请求，因为请求的资源禁止访问。</li>
<li><code>404 Not Found</code>：未找到。请求的资源在服务器上不存在。</li>
<li><code>500 Internal Server Error</code>：服务器内部错误。服务器在处理请求时遇到意外错误。</li>
</ul>
<blockquote>
<p>4XX client error or 5XX server error response</p>
</blockquote>
<hr />
<pre><code class="language-python">import requests
r = requests.get(&#x27;https://httpbin.org/get&#x27;)
r.status_code
print(r.status_code)
</code></pre>
<ul>
<li>If we made a bad request (a 4XX client error or 5XX server error response), we can raise it with <a href="https://requests.readthedocs.io/en/latest/api/#requests.Response.raise_for_status">Response.raise_for_status()</a>:</li>
</ul>
<pre><code class="language-python">bad_r = requests.get(&#x27;https://httpbin.org/status/404&#x27;)
bad_r.status_code
404

bad_r.raise_for_status()
Traceback (most recent call last):
  File &quot;requests/models.py&quot;, line 832, in raise_for_status
    raise http_error
requests.exceptions.HTTPError: 404 Client Error
</code></pre>
]]></content><link href="https://github.com/dululu/GitNote/issues/34"/><category term="Python"/><published>2024-03-08T19:53:42+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/33</id><title>问题汇总3</title><updated>2024-07-31T17:19:59.843705+00:00</updated><content type="html"><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox"> 相对路径和绝对路径</li>
<li><input checked="" disabled="" type="checkbox"> <code>int</code>和<code>char</code></li>
<li>
<input disabled="" type="checkbox"> <code>LF</code> 与<code>CRLF</code>
<strong><em>路径</em></strong><ul>
<li><strong>绝对路径</strong>是指从文件系统的根目录开始一直到目标文件或目录的完整路径。如<code>C:\Users\Username\Documents\File.txt</code>是一个<strong>Windows</strong>系统下的绝对路径。<em>在类Unix系统（如<strong>Linux和macOS</strong>）中</em>，绝对路径以斜杠（/）开始，然后按照目录结构一级一级地指定目标位置。例如，<code>/home/username/Documents/file.txt</code>是一个Linux系统下的绝对路径。</li>
<li>相对路径是相对于当前工作目录或当前所在位置的路径。它不需要提供完整的路径，而是根据当前位置和目标位置之间的相对位置来指定。相对路径可以使用特殊符号来表示路径关系。在Windows系统中，两个常用的特殊符号是&quot;..&quot;和&quot;.&quot;。&quot;..&quot;表示上一级目录，&quot;.&quot;表示当前目录。例如，假设当前工作目录是<code>C:\Users\Username</code>，要指向文件<code>C:\Users\Username\Documents\File.txt</code>，可以使用相对路径<code>..\Documents\File.txt</code>。</li>
</ul>
</li>
</ul>
<p><strong><em><code>int</code>和<code>char</code></em></strong>
<code>char</code>是字符类型，用于表示单个字符。它可以存储字母、数字、标点符号等字符。</p>
<p><strong><code>LF</code> 与<code>CRLF</code></strong>
LF代表&quot;Line Feed&quot;，在ASCII码中对应于十进制值10或十六进制值0x0A。它在Unix、Linux和macOS系统中通常被用作行结束符。</p>
<p>CRLF代表&quot;Carriage Return Line Feed&quot;，在ASCII码中对应于十进制值13和10，或十六进制值0x0D和0x0A。它在Windows系统中通常被用作行结束符。</p>
<p>这两种表示形式的区别在于行结束符的编码方式。在Unix、Linux和macOS中，每行的结束只使用LF字符；而在Windows中，每行的结束使用两个字符组成的序列CRLF。</p>
<p>需要注意的是，不同的操作系统在处理文本文件时可能对行结束符有不同的要求。大多数文本编辑器和操作系统能够自动识别和处理不同的行结束符。然而，当在不同操作系统之间交换文本文件时，可能需要注意行结束符的转换，以确保文件在不同的环境中正确显示和处理。
#32 </p>
]]></content><link href="https://github.com/dululu/GitNote/issues/33"/><category term="问题记录"/><published>2024-03-08T07:57:24+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/32</id><title> 计算机中，数据可以使用不同的编码方式进行保存和表示</title><updated>2024-07-31T17:19:59.962800+00:00</updated><content type="html"><![CDATA[<h3>关于<code>char</code>和<code>int</code></h3>
<ul>
<li>
众所周知在c++中<code>char</code>占一个字节，8位；<code>int</code>占4个字节，32位；
在计算机中数据最终是通过<strong>二进制编码</strong>保存。而<strong>字符编码</strong>用于将字符映射到二进制数据。
常见的字符编码：<ul>
<li>ASCII（美国标准码）</li>
</ul>
</li>
</ul>
<img width="328" alt="image" src="https://github.com/dululu/notes/assets/64392262/2caf88c7-a146-40cf-937a-3c8a2fc9ba3b">
<p>使用<code>ASCII字符</code>代表26个字母大小写，还有0~9的字符。所以最终本质都是<code>二进制</code>编码，因为只有占一个字节，只能从0—255。</p>
<blockquote>
<p>还有Unicode 和 UTF-8（一种可变长度的 Unicode 编码）</p>
</blockquote>
]]></content><link href="https://github.com/dululu/GitNote/issues/32"/><category term="cpp"/><published>2024-03-07T12:33:39+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/31</id><title>AI TOOL</title><updated>2024-07-31T17:20:00.135127+00:00</updated><content type="html"><![CDATA[<ul>
<li><a href="https://poe.com/chat/230btdq08a1544w930h">poe</a></li>
</ul>
<blockquote>
<p>集成gpt,就是有点卡</p>
</blockquote>
<ul>
<li><a href="https://devv.ai/">Devv</a></li>
</ul>
<blockquote>
<p>代码专用，一步一步挺好的</p>
</blockquote>
<ul>
<li><a href="https://www.perplexity.ai/">perplexity</a></li>
</ul>
<blockquote>
<p>还行，可以交互</p>
</blockquote>
<p>网络代理问题：
1.https://doc.miyun.app/
2.规则代理，换路线。
3.清理DNS缓存</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/31"/><category term="Top"/><category term="工具使用"/><published>2024-03-06T22:06:29+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/30</id><title>git使用</title><updated>2024-07-31T17:20:00.256451+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>原则上是碰到问题再用</p>
</blockquote>
<ol>
<li>删除GitHub文件</li>
<li><code>.gitignore</code></li>
<li><code>stage</code></li>
<li><code>pull</code>和<code>push</code>使用</li>
<li><code>ssh key</code>使用</li>
<li><code>Personal access tokens (classic)</code>个人访问令牌</li>
<li>代码回滚</li>
</ol>
<ul>
<li>
<input checked="" disabled="" type="checkbox"> 如何在本地删除传到GitHub的文件<ul>
<li>首先进入文件仓库</li>
<li>如果想要本地和GitHub一起删除<code>git rm file</code>,只是删除云端<code>git rm --cached file</code></li>
<li><code>git commit -m &quot;delete a file&quot;</code>和<code>git push origin main</code></li>
</ul>
</li>
</ul>
<p>⚠️如果删除单个文件直接删，删除文件夹<code>git rm file -r</code></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>.gitignore</code>
使用斜杠（/）指定目录或文件夹。
使用星号（*）表示通配符，匹配零个或多个字符。
使用问号（?）表示通配符，匹配一个字符。
使用感叹号（!）表示取反，即不忽略该模式匹配到的内容。
使用井号（#）表示注释，该行后面的内容将被忽略。</li>
</ul>
<pre><code># 忽略编译生成的文件
*.o
*.exe
# 忽略目录
/build/
/dist/
# 不忽略特定文件
!src/main.c
</code></pre>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>stage</code>
在Git中，&quot;stage&quot;是指将文件或更改添加到暂存区（也称为索引）的过程。暂存区是位于Git仓库中的一个中间区域，用于准备将要提交的更改。
当您对文件进行修改后，可以使用<code>git add .</code>命令将更改添加到暂存区.</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/30"/><category term="工具使用"/><published>2024-03-06T20:35:39+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/29</id><title>一些常用函数</title><updated>2024-07-31T17:20:00.363178+00:00</updated><content type="html"><![CDATA[<ul>
<li><input disabled="" type="checkbox"> <code>strcpy</code>函数</li>
<li><input disabled="" type="checkbox"> <code>memset</code>函数</li>
<li><input disabled="" type="checkbox"> <code>atoi</code>函数</li>
<li><input disabled="" type="checkbox"> <code>sizeof()</code>运算符</li>
</ul>
<ol>
<li><code>strcpy</code>
strcpy 是一个常见的 C 语言字符串操作函数，用于将一个字符串复制到另一个字符串中。
函数原型如下：</li>
</ol>
<pre><code class="language-c++">char* strcpy(char* destination, const char* source);
</code></pre>
<p>2.<code>memset</code>
memset 是一个 C 语言中的函数，用于将一块内存区域的每个字节设置为指定的值。</p>
<pre><code class="language-c++">void* memset(void* ptr, int value, size_t num);
memset(str, &#x27;A&#x27;, 10); // 将 str 的前 10 个字节设置为 &#x27;A&#x27;
</code></pre>
<p>memset 函数通常用于初始化内存区域或将内存区域清零。</p>
<p>3.<code>atoi</code>
atoi 是一个 C 语言中的函数，用于将字符串转换为整数（integer）。
函数原型如下</p>
<pre><code class="language-cpp">int atoi(const char* str);
</code></pre>
<p>它会忽略字符串开头的空白字符，直到找到第一个非空白字符。然后，从该字符开始解析连续的数字字符，直到遇到非数字字符为止。它将解析得到的数字字符序列转换为整数并返回。
4.<code>sizeof()</code>
用于计算数据类型或变量的字节大小。
type 是一个数据类型，如 <code>int</code>、<code>float</code>、<code>char</code> 等，或者是一个具体的变量、数组、结构体等表达式。
函数的参数必须是_变量_。<code>int</code>是操作符</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/29"/><category term="cpp"/><published>2024-03-05T14:48:25+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/28</id><title>EnglishWords</title><updated>2024-07-31T17:20:00.472970+00:00</updated><content type="html"><![CDATA[<h4><a href="https://translate.google.com.hk/?hl=zh-CN">谷歌翻译</a></h4>
<h3><a href="https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/%E8%8B%B1%E8%AF%AD-%E6%B1%89%E8%AF%AD-%E7%AE%80%E4%BD%93/backup">剑桥翻译</a></h3>
<p><strong><em>From where ?</em></strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Obsdian</li>
<li><input checked="" disabled="" type="checkbox"> Github</li>
<li><input checked="" disabled="" type="checkbox"> 常见</li>
</ul>
<h2><strong>obsdian</strong></h2>
<ul>
<li>interval       间隔，间距</li>
<li>vault           保险库，金库</li>
<li>backup       备份，替补，伴奏</li>
<li>millisecond 毫秒</li>
<li>miscellaneous 杂项，冗杂</li>
<li>submodules 子模块/组</li>
</ul>
<h2><strong>Github</strong></h2>
<ul>
<li>fatal           致命的，有害的，命中注定的</li>
<li>permanently  永久地，永恒地</li>
</ul>
<h2><strong>常见</strong></h2>
<ul>
<li>argument/arg  争论，论据/变元，自变量</li>
<li>parameter 参数</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/28"/><category term="工具使用"/><published>2024-03-05T11:54:32+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/27</id><title>面向连接和面向消息的套接字</title><updated>2024-07-31T17:20:00.612181+00:00</updated><content type="html"><![CDATA[<p>面向连接的套接字：stream</p>
<ul>
<li>收发数据的套接字内有缓冲（buffer）,就是字节数组。不存在数据边界</li>
<li>缓冲可能·被填满，套接字无法再接收数据，传输套接字停止传输。</li>
<li>根据接收端状态传输数据。</li>
<li>套接字必须一一对应。</li>
<li>可靠的，按顺序传递的，基于<strong>字节</strong>的，面向连接的。</li>
</ul>
<p>面向消息的：</p>
<ul>
<li>更快的速度，无法避免数据丢失或损毁。</li>
<li>存在数据边界，传输的数据大小有限制。</li>
<li>接受数据的次数应该和传输数据的次数<strong>相同</strong>。</li>
<li>不存在<strong>连接</strong>的概念。</li>
<li>不可靠的，不按顺序的，数据高速传输为目的。</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/27"/><published>2024-03-03T19:26:57+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/26</id><title>问题汇总2</title><updated>2024-07-31T17:20:00.724506+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>list2</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 关于代理</li>
<li><input checked="" disabled="" type="checkbox"> 代码中的<code>0</code></li>
<li><input checked="" disabled="" type="checkbox"> 关于<code>.gitignore</code></li>
<li><input checked="" disabled="" type="checkbox"> <code>pull request</code></li>
</ul>
<h3>系统代理</h3>
<p>系统代理是一种在操作系统级别设置的代理配置，它会影响整个计算机上的所有网络连接。通过配置系统代理，您可以将所有网络流量通过代理服务器进行转发，以实现对网络流量的控制和管理。</p>
<blockquote>
<p>在示意图中，我们将使用三个要素来表示系统代理的设置：
操作系统设置：这是您的计算机操作系统的网络设置界面。
代理服务器地址和端口：这是代理服务器的网络地址和端口号。
代理类型：这表示您可以选择的不同代理类型，例如HTTP代理、SOCKS代理等。</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>代理服务器的地址为 127.0.0.1，端口号为 7897。请注意，127.0.0.1 是本地回环地址，通常用于指向本机的网络接口。端口号 7897 是代理服务器<strong>监听</strong>的网络端口。</p>
</blockquote>
</li>
<li>TUN（全称为网络隧道）模式是一种在计算机网络中使用的网络设备驱动程序模式。它可以在操作系统级别创建虚拟网络接口，将网络数据包封装在其他协议中进行传输。</li>
<li>局域网内共享代理：在局域网中连接Clash代理服务器后，其他设备也可以通过相同的代理进行网络连接。这意味着您可以在整个局域网中共享代理服务，使所有设备都能享受到相同的优势和功能。</li>
<li><strong>全局和规则</strong></li>
</ul>
<h4><strong>全局代理（Global Proxy）模式</strong>：</h4>
<p>全局代理模式是将所有的网络流量都通过代理服务器进行转发的模式。在全局代理模式下，所有的网络请求都会经过代理服务器，无论是浏览器、应用程序还是系统级别的请求。这意味着所有的网络流量都会通过代理服务器进行转发，无论目的地是什么。全局代理模式通常用于需要完全隐藏IP地址或绕过特定网络限制的情况。</p>
<h4><strong>规则代理（Rule-based Proxy）模式</strong>：</h4>
<p>规则代理模式是根据预先定义的规则，选择性地将特定的网络流量通过代理服务器进行转发的模式。在规则代理模式下，您可以设置一系列规则，这些规则可以基于域名、IP地址、URL路径等来决定是否使用代理服务器转发请求。规则代理模式允许您更加灵活地控制代理的使用，可以根据不同的需求和场景进行定制。</p>
<h3>代码中的<code>0</code></h3>
<ol>
<li><code>if</code>条件中的0</li>
</ol>
<ul>
<li>条件 0 的求值结果为 false，因为大多数编程语言中，值为 0 被认为是 false，而非零值被认为是 true。因此，在 if 语句中的代码将不会被执行。</li>
</ul>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main() {
    if (0) {
        printf(&quot;这段代码不会被执行。\n&quot;);
    } else {
        printf(&quot;这段代码会被执行。\n&quot;);
    }
    return 0;
}
</code></pre>
<ol start="2">
<li><code>exit()</code>中的0</li>
</ol>
<p>exit(0) 是一个函数调用，用于在程序中终止执行并返回一个退出状态码。在C语言中，exit() 函数用于正常退出程序。
具体到 exit(0)，它表示程序成功地执行完毕并以状态码 0 退出。在大部分操作系统中，状态码 0 表示程序成功执行，没有发生错误。</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
    printf(&quot;程序执行完毕！\n&quot;);
    exit(0);
}
</code></pre>
<p>3.正确使用<code>.gitignore</code>
.gitignore 是一个用于指定 Git 版本控制系统忽略哪些文件和文件夹的配置文件。当你在 Git 仓库中创建 .gitignore 文件并指定要忽略的内容后，Git 在进行版本控制时将自动忽略这些文件和文件夹，不对其进行跟踪或提交。</p>
<p>.gitignore 文件的语法规则如下：</p>
<p>每一行表示一个要忽略的模式。
使用斜杠（/）指定目录或文件夹。
使用星号（*）表示通配符，匹配零个或多个字符。
使用问号（?）表示通配符，匹配一个字符。
使用感叹号（!）表示取反，即不忽略该模式匹配到的内容。
使用井号（#）表示注释，该行后面的内容将被忽略。</p>
<pre><code class="language-bash"># 忽略编译生成的文件
*.o
*.exe

# 忽略目录
/build/
/dist/

# 不忽略特定文件
!src/main.c
</code></pre>
<p>4.<code>pull request</code>
Pull Request（PR）是一种在分布式版本控制系统中协作开发的机制，常见于Git仓库管理工具（如GitHub、GitLab、Bitbucket等）。它允许开发者将自己的代码变更贡献给项目的原始代码库，并请求原始代码库的维护者合并这些变更。</p>
<blockquote>
<p>要在 GitHub 上创建 Pull Request，您需要按照以下步骤操作：</p>
</blockquote>
<ul>
<li>Fork 项目：访问您要贡献代码的原始项目页面，点击页面右上角的 &quot;Fork&quot; 按钮。这将在您的 GitHub 账户中创建一个该项目的副本。</li>
<li>克隆仓库：在您的 GitHub 账户中找到 Fork 后的项目，点击 &quot;Code&quot; 按钮并获取仓库的克隆 URL。在本地使用 Git 命令或 Git 客户端，使用该克隆 URL 将仓库克隆到您的本地环境中。</li>
<li>创建新分支：在本地仓库中创建一个新的分支，用于进行您的代码更改。可以使用 git checkout -b branch-name 命令来- - 创建并切换到新分支，其中 branch-name 是您为分支指定的名称。</li>
<li>进行代码更改：在新分支上进行代码更改，根据您的需求添加、修改或删除代码文件。</li>
<li>提交代码：将代码更改提交到新分支中。使用 Git 命令 git add 将更改的文件添加到暂存区，然后使用 git commit 提交更改，并使用 -m 参数添加提交消息。</li>
<li>推送分支：使用 git push origin branch-name 命令将您的新分支推送到您的 GitHub 仓库。</li>
<li>创建 Pull Request：在您的 GitHub 仓库页面上，切换到新分支，点击 &quot;Pull Request&quot; 或 &quot;New Pull Request&quot; 按钮。</li>
<li>比较更改：确保 &quot;base repository&quot; 是指向原始项目，&quot;base&quot; 分支是您要将更改合并到的目标分支，&quot;head repository&quot; 是指向您的仓库，&quot;compare&quot; 分支是您的新分支。</li>
<li>提交 Pull Request：检查 Pull Request 的详细信息，包括标题、描述和更改的文件。确认后，点击 &quot;Create Pull Request&quot; 提交您的 Pull Request。</li>
<li>等待审核：项目维护者将会对您的代码进行审核和评审。他们可能会提出问题、建议修改或讨论更改。</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/26"/><category term="问题记录"/><published>2024-02-27T16:29:26+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/22</id><title>银鞍照白马，洒踏如流星。</title><updated>2024-07-31T17:20:00.862582+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>为什么起这么名字，因为最近太背了，我希望自己能过得潇洒一点。看罗翔老师的《十三邀》采访，听他念一遍这句诗就喜欢上了，如此洒脱不羁，以前的我也是这样的哈哈。我已经23了，我总是疏于表达自己的情感，想得很好，实施起来却非常的困难，喜欢就是喜欢，不喜欢就是不喜欢，撞到南墙之后才知道南墙到底硬不硬，快速试错，降低犯错的机会成本，从错误中寻找正确，人总是要犯错的，完美主义不可行。</p>
</blockquote>
<ul>
<li>最近一年发生了许多事情，让我陷入了一个又一个循环中，失败又失败。颓废且丑陋，因为我改变不了别人，也改变不了自己，那就让自己一天一天的变好。 </li>
</ul>
<h1>毕业季</h1>
<p>看到其他同学的未来是那样的光明有着落，再看看自己，朋辈的压力一点也不小，可是没有人理解，只是一个劲的去催促，非常非常的down</p>
<h1>找工作</h1>
<p>大海捞针，沉默的大多数，个人的命运在时代的滚滚洪流之下简直不值一提，可是没有人在乎，这一切只能归于你【自己】的原因。这就是廉价劳动力的命，这就是社会现实。</p>
<h1>年底</h1>
<p>真的快撑不过去了，我的快乐被一点一点的榨干，只剩下麻木的躯壳。今年过年那就不回去了，反正也是那样，没有人真正的关心我，只是关心我有没有有用，有没有丢他的脸面，虚伪和丑陋和霸权，让我绝望，感觉像是原始社会。7月份的辱骂，正月的指责，他自己没有用，却将我一次又一次的推到悬崖之上。</p>
<h1>now</h1>
<ul>
<li>先找到一份工作，最好是c++相关的。</li>
<li>拯救坏情绪。</li>
<li>早起</li>
<li>将自己的烦恼写出来，一条一条的陈列。</li>
<li>健身</li>
<li>健康饮食</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/22"/><category term="日记"/><published>2024-01-21T15:25:57+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/21</id><title>周记</title><updated>2024-07-31T17:20:01.199614+00:00</updated><content type="html"><![CDATA[<p>见贤思齐
灵感来源:https://coldrain.ink/#/home
有计划➕执行力强➕web3：<a href="https://polebug.github.io/">https://polebug.github.io/</a></p>
]]></content><link href="https://github.com/dululu/GitNote/issues/21"/><published>2024-01-17T20:45:12+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/20</id><title>Neovim </title><updated>2024-07-31T17:20:01.331032+00:00</updated><content type="html"><![CDATA[<h3>Step1:安装<a href="https://github.com/neovim/neovim/blob/master/INSTALL.md">Neovim</a></h3>
<p>Ubuntu+WSL</p>
<pre><code class="language-powershell-interactive">sudo apt-get install python-dev python-pip python3-dev
sudo apt-get install python3-setuptools
sudo easy_install3 pip
//卸载
sudo cmake --build build/ --target uninstall
</code></pre>
<h3>Step2:Neovim 基础配置</h3>
<p>Neovim 配置文件不是<code> .vimrc</code></p>
<p>而是保存在<code> ~/.config/nvim/init.vim</code>,但是 init.vim 只作为入口，真正的配置，是加载的其他的 lua 配置文件
<a href="https://martinlwx.github.io/zh-cn/config-neovim-from-scratch/">写的太好了😎😎😎</a></p>
<p>😅 然而我还没弄好 @dululu [2024年01月14日 23:21:49] </p>
]]></content><link href="https://github.com/dululu/GitNote/issues/20"/><published>2024-01-14T15:21:59+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/18</id><title>快速学习C和C++，基础语法和优化策略（三）</title><updated>2024-07-31T17:20:01.498129+00:00</updated><content type="html"><![CDATA[<h3>函数 functions</h3>
<h4>内联函数 inline</h4>
<p>程序运行效率,用空间换时间。</p>
<pre><code class="language-cpp">// 使用函数调用
int main()
{
    int num1 =20;
    int num2 = 30;
    int maxv = max_function(num1,num2);
    maxv = max_function(numn,maxv);
}
//
float max_function(float a,float b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}
//频繁调用max_function
</code></pre>
<p>可以用<code>inline</code>,用空间换时间。</p>
<pre><code class="language-cpp">int main()
{
    int num1 =20;
    int num2 = 30;
    int maxv = {   //示意图，没有函数调用，生成的机器代码变多。
    if(num1&gt;num2)
        return num1;
    else
        return num2;}
    maxv = {
    if(numn&gt;maxv)
        return numn;
    else
        return maxv;}
}
// 只会建议编译器执行这样的命令，编译器根据整体情况来判断
inline float max_function(float a,float b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}
</code></pre>
<p>使用<code>宏</code>操作</p>
<pre><code class="language-cpp">#define MAX_MACRO(a&gt;b) ?(a):(b)  //比较大小
// 不局限于某一种特定的数据类型
// 宏 是文本替换
int num1 = 20,num2 = 30;
maxv = MAX_MACRO(num1++,num2++);
maxv = MAX_MACRO(num1++ &gt; num2++) ?(num1++):(num2++) 
cout&lt;&lt; maxv &lt;&lt; endl;  //31
cout &lt;&lt;&quot;num2=&quot;&lt;&lt;num2&lt;&lt;endl; //mun2=32
//num1 =21,因为num1没有被再次调用
</code></pre>
<h4>默认参数 Default arguments</h4>
<ul>
<li>
<p>默认参数要从尾部开始设
<img width="584" alt="image" src="https://github.com/dululu/notes/assets/64392262/8e579ce4-9d4e-4f55-b2b3-a6548fa949cf"></p>
</li>
<li>
<p>默认参数不能重定义，每个参数只能有一个默认值</p>
</li>
</ul>
<h4>函数重载 overloading</h4>
<p>使用同样的<strong>函数名</strong>，但是做的是不同的事。</p>
<pre><code class="language-cpp">&lt;cmath&gt;
double round(double x);
float round(flaot x);
long duble round(long double x);
</code></pre>
<p><code>cpp</code> 依赖参数列表来查询，选择不同的函数。</p>
<h4>函数模板 templates</h4>
<p>当函数的实现<strong>逻辑</strong>都非常相同的时候，就可以使用函数模板。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
T sum(T x, T y)
{
cout&lt;&lt;&quot;The input type is&quot; &lt;&lt; typeid(T).name &lt;&lt;endl;
return x+y;
}
// 实例化
template double sum(double,double);
template char sum&lt;&gt;(char,char);
template int sum(int,int);
</code></pre>
<h4>函数指针和函数引用 Function pointers and References</h4>
<ul>
<li>函数指针</li>
</ul>
<pre><code class="language-cpp">norm_ptr //指针指向指令区
float norml1(float x, float y);
float norml2(float x, float y);
float (*norm_ptr)(float x, float y);
</code></pre>
<ul>
<li>函数引用</li>
</ul>
<pre><code class="language-cpp">float norml1(float x, float y);
float norml2(float x, float y);
float (&amp;norm_ptr)(float x, float y) = norml1;
</code></pre>
]]></content><link href="https://github.com/dululu/GitNote/issues/18"/><category term="cpp"/><published>2024-01-11T06:35:36+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/17</id><title>快速学习C和C++，基础语法和优化策略。（二）</title><updated>2024-07-31T17:20:01.628824+00:00</updated><content type="html"><![CDATA[<h3>P5:结构</h3>
<h4>结构体，联合体，枚举类型</h4>
<ul>
<li><code>struct</code> 定义结构体</li>
</ul>
<pre><code class="language-cpp">struct Student{
    char name[4];
    int born;
    bool male;
};
struct Student stu;
strcpy(stu.name,&quot;X&quot;);
stu.born = 2000;
stu.male = false;

struct Student stu = {&quot;K&quot;,23,true} //初始化，c语言必须要前面的struct
</code></pre>
<p>在c++中class和struct几乎没区别。</p>
<ul>
<li>union
所有成员共享同一个内存，有相同的地址，只是长度不同</li>
</ul>
<img width="265" alt="image" src="https://github.com/dululu/notes/assets/64392262/4c1dd929-7564-49b7-ab0d-d69a232d221e">
<pre><code class="language-cpp">union ipv4address{
    std::unit32_t address32;
    std::unit8_t address[4];
//首地址相同，以最大的对象所占的内存大小为准。
}
</code></pre>
<ul>
<li>enum 枚举</li>
</ul>
<blockquote>
<p>enum make a new type</p>
</blockquote>
<pre><code class="language-cpp">enum color {white,black,blue,red,pink,yellow,num_color}
enum color pen_color = blue;
pen_color = color(3);
</code></pre>
<h4>指针 Pointers</h4>
<pre><code class="language-cpp">&amp; //去变量或对象的地址
* //对指针取内容，取地址里面的那块内容
int *p1 = NULL, *p2 =NULL;
</code></pre>
<ul>
<li><code>p-&gt;member</code></li>
<li><code>(*p).member</code></li>
</ul>
<h4>内存管理 Allocate memory</h4>
<ul>
<li><code>C</code>
<code>Heap</code>:堆，动态申请内存
<code>stack</code>:栈，局部变量，临时变量，<code>int i</code>
堆栈相向而行。
<img width="203" alt="image" src="https://github.com/dululu/notes/assets/64392262/01c6886d-dd60-43f5-ac83-bbed9643be44"></li>
</ul>
<pre><code class="language-cpp">int a = 0;
int b = 0;
int c = 0; 
cout&lt;&lt;&amp;a&lt;&lt;&amp;b&lt;&lt;&amp;c&lt;&lt;endl;

int *p1 = (*int) malloc(4);
int *p2 = (*int) malloc(4);
int *p3 = (*int) malloc(4);
cout&lt;&lt;p1&lt;&lt;p1&lt;&lt;p3&lt;&lt;endl;
</code></pre>
<img width="191" alt="image" src="https://github.com/dululu/notes/assets/64392262/55fba445-8fbd-488d-a938-b707dd77181a">
<blockquote>
<ul>
<li>abc地址越来小，地址连续。</li>
<li>p1p2p3地址越来越大，malloc(4)分配4个字节,9-a-b,每一个差16个字节，但地址是16位对齐,所以剩下的4个字节就浪费掉了。</li>
</ul>
</blockquote>
<ul>
<li>申请内存 Memory allocation</li>
</ul>
<pre><code class="language-cpp">void* malloc(size_t size)
int * p1 =  (int*)malloc(4);//初始化
free（p1）;释放内存
</code></pre>
<ul>
<li><code>c++</code></li>
</ul>
<pre><code class="language-cpp">new//
int *p1 = new int;
int *p2 = new int();
int *p3 = new int(5);
int *p1 = new int{};
//
int *pad = new int[16];
int *p9 = new Student[16];
//释放
delete p1;
</code></pre>
]]></content><link href="https://github.com/dululu/GitNote/issues/17"/><category term="cpp"/><published>2024-01-10T17:34:56+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/16</id><title>炒蛋问题</title><updated>2024-07-31T17:20:01.742332+00:00</updated><content type="html"><![CDATA[<p><a href="https://poe.com/ChatGPT">为什么不问一问GPT呢😊😊😊</a></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> gdb是啥？</li>
<li><input checked="" disabled="" type="checkbox"> 为啥WSL可以编译cpp</li>
<li><input checked="" disabled="" type="checkbox"> 常见单位换算</li>
<li><input checked="" disabled="" type="checkbox"> 为什么是2^32^B</li>
<li><input checked="" disabled="" type="checkbox"> ++i 和 i++</li>
<li><input checked="" disabled="" type="checkbox"> clang 与 g++</li>
<li><input checked="" disabled="" type="checkbox"> linux常用命令1️⃣</li>
</ul>
<h3>gdb是啥？</h3>
<ul>
<li>GNU Debugger</li>
</ul>
<blockquote>
<p>gdb是一种由GNU开发的免费的调试器，它可以帮助程序员在开发过程中定位和修复代码中的错误。它提供了一系列命令和功能，可以帮助用户查看程序的内部状态、执行代码步骤、跟踪变量的值等。</p>
</blockquote>
<h3>为啥WSL可以编译cpp</h3>
<blockquote>
<p>WSL是Windows Subsystem for Linux的缩写，它允许Windows用户在其系统上运行Linux环境。因此，通过WSL，用户可以使用Linux上的编译器和工具来编译和运行C++程序。</p>
</blockquote>
<ul>
<li>为了编译C++程序，您还需要安装g++编译器。它是GNU编译器集合中专门用于编译C++程序的工具，可以将源代码编译成可执行文件。在WSL中，您可以通过apt-get命令来安装g++。</li>
<li>可以使用命令“g++ --version”来查看系统中是否已安装g++，以及其版本信息。如果系统中没有安装，您可以通过apt-get命令来安装。
<img width="357" alt="image" src="https://github.com/dululu/notes/assets/64392262/db79ccb8-5c41-478b-b015-d3116528821a"></li>
</ul>
<h3>常见单位换算</h3>
<ul>
<li>1 byte = 8 bit
电脑<strong>存储</strong>的单位有 B（字节）、KB（千字节）、MB（兆字节）、GB（千兆字节）、TB（太字节）和 PB（拍字节）。</li>
<li>
它们之间的换算关系为：<ul>
<li>1 KB = 2 的 10 次方 B，</li>
<li>1 MB = 2 的 20 次方 B，</li>
<li>1 GB = 2 的 30 次方 B，</li>
<li>1 TB = 2 的 40 次方 B，</li>
<li>1 PB = 2 的 50 次方 B。</li>
</ul>
</li>
<li>
通常用来表示<strong>网速</strong>的单位有 bps（每秒比特数）、Kbps（千比特每秒）、Mbps（兆比特每秒）和 Gbps（千兆比特每秒）。它们之间的换算关系为：<ul>
<li>1 Kbps = 2 的 10 次方 bps，</li>
<li>1 Mbps = 2 的 20 次方 bps，</li>
<li>1 Gbps = 2 的 30 次方 bps。</li>
</ul>
</li>
</ul>
<h3>为什么是2^32^B</h3>
<p><a href="https://www.zhihu.com/question/423135323">nice</a>
注意区分<strong>容量</strong>和<strong>长度</strong></p>
<p>说长度的时候就是说这个地址有几个bit</p>
<p>说容量的时候，意思是在这个地址长度下，最多可能存储多少bit</p>
<blockquote>
<ul>
<li>我们可以说一个32位<code>int</code>型变量占的空间为4B，也可以说计算机里面一个32位寄存器可以记录的数据量为4B</li>
<li>32位机时代因为<strong>计算机寄存器</strong>的的容量为32位，那么如果我们只想<strong>用一个寄存器来储存一个内存地址</strong>的话，那么我们最多可以表示2的32次方个不同的内存地址，然后每个内存地址下可以存储1B也就是8bit的信息(<strong>注意不是每个位都有自己的地址)</strong>，所以这种设定下支持的最大内存容量就是2^32B = 2^22KB = 2^12MB = 2^2G = 4G。当然这只是一个上界，有时候内存特殊地址有特殊作用，所以事实上32位Windows支持的最大内存没那么大。</li>
<li>一个地址控制一个字节，所以最终结果是2^32B,计算机中存储器以字节（B）为基本单位。</li>
</ul>
</blockquote>
<h3>++i 和 i++</h3>
<p>两者都是 C++ 中的自增运算符，i++ 表示先使用 i 的值，再对 i 进行加 1 操作，++i 表示先对 i 进行加 1 操作，再使用 i 的值。它们在大多数情况下都可以达到相同的效果，但是在某些特殊情况下会有差异，比如在 for 循环中的使用。</p>
<pre><code class="language-cpp">#define MAX_MACRO(a&gt;b) ?(a):(b)  //比较大小
// 不局限于某一种特定的数据类型
// 宏 是文本替换
int num1 = 20,num2 = 30;
maxv = MAX_MACRO(num1++,num2++);
maxv = MAX_MACRO(num1++ &gt; num2++) ?(num1++):(num2++) 
cout&lt;&lt; maxv &lt;&lt; endl;  //31
cout &lt;&lt;&quot;num2=&quot;&lt;&lt;num2&lt;&lt;endl; //mun2=32
</code></pre>
<h4>clang 与 g++</h4>
<p><strong>系统(W/L)-&gt;编译器(clang/g++)-&gt;</strong>
<code>/$</code> 根目录的符号
<code>~$</code> 当前用户的主目录的符号<br />
<code>sudo</code> 是Linux系统中用来获得超级用户权限的命令。使用sudo可以让您以超级用户的身份来运行指定的命令。</p>
<h5>为了在WSL 2中安装Clang，您可以使用WSL提供的apt-get命令来安装。具体的操作步骤如下：</h5>
<ul>
<li>打开WSL 2终端。</li>
<li>运行命令&quot;sudo apt-get update&quot;来更新软件源。</li>
<li>运行命令&quot;sudo apt-get install clang&quot;来安装Clang。</li>
<li>安装完成后，您可以使用命令&quot;clang -v&quot;来验证安装是否成功。</li>
<li><code>clang -std==c++11 1.cpp</code></li>
</ul>
<h4>常用命令</h4>
<h5>文件管理</h5>
<ul>
<li>路径</li>
</ul>
<pre><code class="language-powershell">cd . 当前
cd.. 上一级
cd / 根
cd ~/ 家
</code></pre>
<ul>
<li>文件</li>
</ul>
<pre><code class="language-powershell">mkdir xxx 创建目录
rm xxx 删除文件 rm xx -r 删除文件夹
mv xxx yy 移动文件/重命名
touch xx 创建文件
cat xx 展示文本
</code></pre>
<ul>
<li>tmux 和 vim
<code>vim-session-pane</code> 平时一般只用一个<code>session</code>，一个<code>session</code>打开多个<code>pane</code></li>
</ul>
<pre><code class="language-powershell">`C+b %` 左右
`C+b “”` 上下
`C+d` 关闭pane
`C+b+d` 挂起session
`tmux+a` 打开挂起的session
</code></pre>
]]></content><link href="https://github.com/dululu/GitNote/issues/16"/><category term="问题记录"/><published>2024-01-08T16:56:58+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/15</id><title>快速学习C和C++，基础语法和优化策略（一）</title><updated>2024-07-31T17:20:01.901878+00:00</updated><content type="html"><![CDATA[<p><strong>视频</strong>：<a href="https://www.bilibili.com/video/BV1Vf4y1P7pq/">ysq</a><br />
<strong>文档</strong>: <a href="https://github.com/ShiqiYu/CPP/tree/main/week01">github</a></p>
<blockquote>
<p>只是差缺补漏，快速过一遍💨💨💨</p>
</blockquote>
<ul>
<li>基础知识：以点带面</li>
<li>
本课重点： <strong>指针和内存管理</strong><ul>
<li><strong>程序效率提升；</strong></li>
<li>介绍OpenCV采用c++特性设计cv::Mat类</li>
<li>介绍ARM开发：ARM开发与Intel的x86开发没有区别。嵌入式ARM，智能设备/ARM服务器。</li>
</ul>
</li>
</ul>
<h2>基础知识</h2>
<h3>P1:编译 Compile</h3>
<ul>
<li>编译C++代码：g++编译器</li>
</ul>
<pre><code class="language-cpp">g++ hello.cpp
g++ hello.cpp  --std=c++11  //告诉编译器采用哪一个标准
//执行成功，生成可执行文件a.out
g++ hello.cpp  --std=c++11 -o hello //更改执行文件名
./hello    //执行
</code></pre>
<ul>
<li>
<p>计算机编程语言发展历史</p>
<ul>
<li>
<p>二进制指令（Binary instructions for CPU）: 纸带打孔表示0和1
<img width="292" alt="屏幕截图 2024-01-08 160010" src="https://github.com/dululu/notes/assets/64392262/2732d2af-d738-4ec2-8378-862c4922b39e"></p>
</li>
<li>
<p>汇编语言（assembly language）</p>
</li>
<li>
<p>高级编程语言（high level language）：</p>
<ul>
<li>C:1973  </li>
<li>C++:1979，c with class</li>
<li>Java:1995 生成字节码class文件</li>
<li>Python:1990 脚本语言</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>编译和链接</strong>
<img width="471" alt="屏幕截图 2023-08-06 153029" src="https://github.com/dululu/notes/assets/64392262/8d6d194d-546e-4828-a15d-ec4b475ca8f4"></p>
</li>
<li>
<p>函数的声明和定义(实现)</p>
</li>
</ul>
<pre><code class="language-cpp">
int mul(int a, int b);  //*.h

int mul(int a, int b) // *.c,*.cpp
{
    return a * b;
}
</code></pre>
<ul>
<li>
<strong>debug</strong><ul>
<li>编译错误：语法错误，如漏了分号</li>
<li>链接错误：Mul.o 与 mul.o</li>
<li>运行时错误：如除数为0，2/0  </li>
</ul>
</li>
</ul>
<h3>P2 预处理和宏 Preprocessor and Macros</h3>
<p><em>在编译之前的步骤</em></p>
<ul>
<li>
<p>定义规则</p>
<ul>
<li>以<code>#</code>开头</li>
<li>每个预处理指令只能占一行</li>
</ul>
</li>
<li>
<p>宏定义</p>
</li>
</ul>
<pre><code class="language-cpp">#define PI 3.14 // PI 不是变量，因为不可改变，理解为文字替换
</code></pre>
<ul>
<li>
<strong>为了避免同一个头文件被包含（include）多次，C/C++ 中有两种宏实现方式：</strong><ul>
<li><code>#pragma once</code></li>
</ul>
<pre><code class="language-cpp">  方式一：
  #ifndef __SOMEFILE_H__
  #define __SOMEFILE_H__
  ... ... // 一些声明语句
  #endif

  方式二：
  #pragma once
  ... ... // 一些声明语句,好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题
</code></pre>
<ul>
<li><code> #ifndef / #define</code></li>
</ul>
<pre><code class="language-cpp">  #ifndef __XXX_H__
  #define __XXX_H__
  int a=1;
  #endif    // 如果没有定义宏__XXX_H_,执行；如果已经定义了，直接结束。变量 a 只被定义一次
  //通过宏定义解决头文件重复包含。
</code></pre>
</li>
</ul>
<h3>P3 简单输入和输出</h3>
<h5>cpp</h5>
<ul>
<li>关于<code>std::ostream cout</code>
<em>c++并未定义任何输入输出语句，取而代之，包含了一个全面的<strong>标准库</strong>(std)来提供IO机制。许多例子都是使用<strong>iostream</strong>，来表示输入输出流。</em></li>
<li><strong>ostream</strong> 是一个数据类型，与<code>int</code>,<code>bool</code>类似</li>
</ul>
<blockquote>
<p>cout is an object of data type ostream in namespace std.
cout是命名空间std中数据类型为ostream的对象。
cin 是 istream</p>
</blockquote>
<ul>
<li><code>&lt;&lt;</code>是一个operator运算符</li>
</ul>
<pre><code class="language-cpp">cin &gt;&gt; a; //从标准输入读数据转成整数类型，存到a里面去。
cout &lt;&lt; &quot;打印&quot;;
</code></pre>
<ul>
<li>运算符重载</li>
</ul>
<pre><code class="language-cpp">    data1 + data2;
    operator+(data1,data2);//等价的函数调用
</code></pre>
<h4>c</h4>
<p>c语言风格输出，<code>printf</code></p>
<ul>
<li><code>int printf(const char *format,....)</code></li>
</ul>
<pre><code class="language-cpp">int v = 100;
printf(&quot;Hello,value = %d\n&quot;, v);
</code></pre>
<p>输入:<code>scanf</code></p>
<pre><code class="language-cpp">int v;
int ret = scanf(&quot;%d&quot;,&amp;v);
</code></pre>
<h3>P4 常见数据类型</h3>
<h4><code>int</code></h4>
<img width="437" alt="屏幕截图 2024-01-10 164256" src="https://github.com/dululu/notes/assets/64392262/af10f131-088c-40d8-a5d5-e54a85743779">
<ul>
<li>
<p><code>short int</code> 2个字节16位</p>
</li>
<li>
<p><code>int</code> <strong>一般都是</strong>32位，</p>
<blockquote>
<p>有符号整数<code>int</code></p>
<ul>
<li>max:0111 1111 1111 1111 1111 1111 1111 1111 =2^31^-1</li>
<li>min: 1111 1111 1111 1111 1111 1111 1111 1111 = -2^31^  （多一个负数的最大值）
低31位存数值，最高位存符号</li>
</ul>
</blockquote>
<blockquote>
<p>无符号整数 <code>unsigned int</code></p>
<ul>
<li>max:1111 1111 1111 1111 1111 1111 1111 1111 =2^32^-1</li>
<li>min:0
32位都用来存数值，所以可以存放16位数乘以16位数的数</li>
</ul>
</blockquote>
</li>
</ul>
<img width="457" alt="image" src="https://github.com/dululu/notes/assets/64392262/037b3596-913c-4264-ba8d-c429f260276c">
<h4><code>sizeof()</code>返回当前数值占多少个字节</h4>
<ul>
<li>sizeof不是一个函数，函数的参数必须是<strong>变量</strong>。sizeof(int)是一个操作符。 </li>
</ul>
<pre><code class="language-cpp"> int i = 0;
 cout&lt;&lt;&quot;sizeof(int)=&quot; sizeof(i) &lt;&lt;endl; //i 不是变量，是一个常量。
</code></pre>
<h4><code>char</code></h4>
<ul>
<li><code>char</code>: <strong>8-bit integer indeed!</strong></li>
<li><code>singned char</code>:-128——127</li>
<li><code>unsigned char</code>:0——255</li>
<li>字符本身就是整数，按照编码。<code>ASCII</code>码</li>
</ul>
<blockquote>
<ul>
<li>中文表示
<code>char16_t</code>,<code>char32_t</code></li>
</ul>
</blockquote>
<h4><code>bool</code></h4>
<p>字节是最小的存储单元,<code>bool</code>占一个字节，8位
<code>bool  d = -21</code>;    只要不是<code>0</code>，那么赋值就是<code>1</code></p>
<h4><code>size_t</code></h4>
<p>无符号整数类型，一般表达<strong>内存大小，元素的个数</strong>。</p>
<ul>
<li>返回电脑支持的最大位数</li>
</ul>
<h4>定义一些符号和宏的使用。</h4>
<img width="287" alt="image" src="https://github.com/dululu/notes/assets/64392262/c7e2f322-f4ef-4dcf-bf8d-ade2557a854e">
<h4>浮点数float</h4>
<img width="559" alt="image" src="https://github.com/dululu/notes/assets/64392262/cff54b1e-8955-45f7-8cf3-079ea925b4a2">
<blockquote>
<p>2.34E+10f : 可以表示为 23400000000，即 234 亿。其中，E 表示 10 的指数，+10 表示 10 的 10 次方，f 表示浮点数。</p>
</blockquote>
<ul>
<li>
32位单精度浮点数<ul>
<li>符号位</li>
<li>系数</li>
<li>精度</li>
</ul>
</li>
<li>double,64位</li>
<li>long double</li>
</ul>
<h4>数组 array[]</h4>
<blockquote>
<ul>
<li>连续的内存,在Java中是一个对象。</li>
<li>可以是存储任何数据类型</li>
</ul>
</blockquote>
<ul>
<li>未知长度的数组，长度由初始化决定。</li>
</ul>
<pre><code class="language-cpp">int num_array[] = {1,3,4,6};// 4 int
</code></pre>
<ul>
<li>把数组传递给函数内部。</li>
</ul>
<blockquote>
<p>values[]是一个指针，代表数组的<strong>首地址</strong>，size_t数组&gt;的长度。</p>
</blockquote>
<pre><code class="language-cpp">//float类型的指针
float array_sum(values[], size_t length);
float array_sum(*values, size_t length);
</code></pre>
<ul>
<li>
<p>数组元素的读写
<code>array1</code>,<code>array2</code>是数组的首地址
<img width="292" alt="image" src="https://github.com/dululu/notes/assets/64392262/da539a3d-efed-44b4-95aa-c26c888dd164"></p>
</li>
<li>
<p>越界</p>
<blockquote>
<p>没有边界检查，在c++中。如果发生越界，按照地址的逻辑直接去进行读和写。</p>
</blockquote>
<ul>
<li>在c++中，数组不是一个对象；<strong>数组是一块连续的内存，数组名指向首地址 ，大小不知道。</strong></li>
<li>缺点：易出错    优点：没有边界检查，效率高</li>
</ul>
</li>
<li>
<p>多维数组
当使用数组名作为<strong>首地址</strong>的时候，必须指定<strong>列</strong>数，不然找不到下一行。 确定偏移的位置。</p>
</li>
</ul>
<img width="563" alt="image" src="https://github.com/dululu/notes/assets/64392262/8f5af34b-a194-4d27-a171-f82da1bf7e79">
<img width="290" alt="image" src="https://github.com/dululu/notes/assets/64392262/382c76d0-1289-4181-adc4-cf52e6bca811">
<h4>字符串 String</h4>
<ul>
<li>
<p>Array-style Strings <strong>数组类型字符串</strong>
最后<strong>一定要加一个0</strong>，来结束字符串。<strong>'\0'</strong> 整数值为0，字符到此为止。否则就会发生越界。
<img width="568" alt="image" src="https://github.com/dululu/notes/assets/64392262/30e4e031-d80d-43fc-b532-3abf3e9ad28d"></p>
</li>
<li>
<p>strlen()返回字符的<strong>数量</strong>,遇到‘\0’就会终止。</p>
</li>
</ul>
<pre><code class="language-cpp">    size_t strlen(const char *str);
</code></pre>
<ul>
<li>常见的字符串</li>
</ul>
<img width="614" alt="image" src="https://github.com/dululu/notes/assets/64392262/549305e1-1c62-4250-a38b-c6d952790231">
<img width="603" alt="image" src="https://github.com/dululu/notes/assets/64392262/374d10eb-3abd-4c60-8d97-bdfdc377b07b">
<p><strong>数组长度为5，字符串长度为4</strong></p>
<ul>
<li>String class
string可以<strong>直接使用运算符</strong>对字符串进行操作。string类没有越界检查
<img width="617" alt="image" src="https://github.com/dululu/notes/assets/64392262/3cb6200f-588d-4207-b89f-0d2c5c2f4988"></li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/15"/><category term="cpp"/><published>2024-01-08T05:46:40+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/9</id><title>需要学习的东西</title><updated>2024-07-31T17:20:02.122479+00:00</updated><content type="html"><![CDATA[<ul>
<li><input disabled="" type="checkbox"> leetcode 700题 <a href="https://leetcode.cn/u/dululu-5/">Task700-28</a> | <a href="https://github.com/dululu/obsgit/tree/main/LeetCode">记录</a></li>
<li><input disabled="" type="checkbox"> 读完20本专业书籍 Zlibrary</li>
<li><input disabled="" type="checkbox"> 刷至少三门专业课视频和作业 <a href="https://github.com/dululu/Lesson">0/3</a></li>
<li><input disabled="" type="checkbox"> 保持好奇心</li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/9"/><category term="TODO"/><published>2024-01-06T16:54:19+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/7</id><title>链接</title><updated>2024-07-31T17:20:02.238659+00:00</updated><content type="html"><![CDATA[<p>格式如下（请参考我下面的 comment）:
冒号为中文冒号 ：</p>
<p>名字：xxxxxx
链接：xxxxxx
描述：xxxxxx</p>
<ul>
<li><input disabled="" type="checkbox"> added
打心后会自动加到友情链接里。</li>
</ul>
<p>❤</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/7"/><category term="Friends"/><published>2024-01-06T15:30:06+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/2</id><title>GitHubActions和github-pages</title><updated>2024-07-31T17:20:02.371309+00:00</updated><content type="html"><![CDATA[<blockquote>
<ul>
<li>最近想重新拾起写日记的习惯，想把blog部署在GitHub上，但是一直不清楚具体方法。<a href="https://polebug.github.io/aboutme/">polebug</a>,本地已经好了，学习如何自动化部署。</li>
<li>突然想在readme文件中实时显示leetcode的刷题数，正好可以用GitHub Actions来运行一个定时任务，定期更新Markdown文档中的刷题数</li>
</ul>
</blockquote>
<h2>怎样使用<code>Action</code></h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana">https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana</a></li>
</ul>
]]></content><link href="https://github.com/dululu/GitNote/issues/2"/><category term="Top"/><published>2024-01-04T17:29:14+00:00</published></entry><entry><id>https://github.com/dululu/GitNote/issues/1</id><title>博客页面</title><updated>2024-07-31T17:20:02.488642+00:00</updated><content type="html"><![CDATA[<h2><a href="https://laike9m.com/blog/people-die-but-long-live-github,122/">People Die, but Long Live GitHub</a></h2>
<ul>
<li>参考来源：<a href="https://github.com/yihong0618/gitblog/issues/209">yihong</a>&amp;<a href="https://github.com/yihong0618/gitblog/issues/177">这个博客开源了</a></li>
<li>
具体方法：<ul>
<li>将.github文件夹，main.py,requirments.txt复制到需要的文件夹下</li>
<li>生成github secret token,在yml文件中改成自己的</li>
<li>将yihong的readme文件复制过来，提交一个issue，创建一个label</li>
<li>刷新GitHub</li>
</ul>
</li>
<li>可以创建属于自己的分区</li>
</ul>
<blockquote>
<ul>
<li><strong>rss</strong> 将仓库名改为自己的仓库名,原始为gitblog,根目录下创建一个feed.xml文件</li>
<li><strong>友情链接</strong> 创建一个标签为<code>Friend</code>的<code>issue</code>,按照格就可自动添加，点上红心❤自动添加。<a href="https://github.com/yihong0618/gitblog/issues/217">详情</a></li>
<li><strong>todolist</strong> 创建一个标签为<code>TODO</code>的<code>issue</code>,注意issue的格式，<code>*</code>不可以，<code>-</code>可以正常显示。</li>
</ul>
</blockquote>
<p><em>跟据<code>label</code>和<code>comment</code>更改</em></p>
<pre><code>COOK_LABEL_LIST = [
    &quot;Cook&quot;,
]
MOVIE_LABEL_LIST = [
    &quot;Movie&quot;,
]
READ_LABEL_LIST = [
    &quot;Read&quot;,
]
DRAMA_LABEL_LIST = [
    &quot;Drama&quot;,
]
PUSHUP_LABEL_LIST = [
    &quot;PushUps&quot;,
]
BANGUMI_LABEL_LIST = [
    &quot;Bangumi&quot;,
]
GAME_LABEL_LIST = [
    &quot;Game&quot;,
]
MONEY_LABEL_LIST = [
    &quot;Money&quot;,
]
MEDITATION_LABEL_LIST = [
    &quot;Meditation&quot;,
]
MORNING_LABEL_LIST = [
    &quot;Morning&quot;,
]
GTD_LABEL_LIST = [
    &quot;GTD&quot;,
]
MY_BLOG_REPO = &quot;yihong0618/gitblog&quot;
GITHUB_README_COMMENTS = (
    &quot;(&lt;!--START_SECTION:{name}--&gt;\n)(.*)(&lt;!--END_SECTION:{name}--&gt;\n)&quot;
)

# add new label here
LABEL_DICT = {
    &quot;Cook&quot;: {&quot;label_list&quot;: COOK_LABEL_LIST, &quot;comment_name&quot;: &quot;my_cook&quot;},
    &quot;Movie&quot;: {&quot;label_list&quot;: MOVIE_LABEL_LIST, &quot;comment_name&quot;: &quot;my_movie&quot;},
    &quot;Read&quot;: {&quot;label_list&quot;: READ_LABEL_LIST, &quot;comment_name&quot;: &quot;my_read&quot;},
    &quot;Drama&quot;: {&quot;label_list&quot;: DRAMA_LABEL_LIST, &quot;comment_name&quot;: &quot;my_drama&quot;},
    &quot;Bangumi&quot;: {&quot;label_list&quot;: BANGUMI_LABEL_LIST, &quot;comment_name&quot;: &quot;my_bangumi&quot;},
    &quot;Game&quot;: {&quot;label_list&quot;: GAME_LABEL_LIST, &quot;comment_name&quot;: &quot;my_game&quot;},
}


##### SHANBAY ######
MY_SHANBAY_USER_NAME = &quot;ufewz&quot;
SHANBAY_CALENDAR_API = &quot;https://apiv3.shanbay.com/uc/checkin/calendar/dates/?user_id={user_name}&amp;start_date={start_date}&amp;end_date={end_date}&quot;
MY_SHANBAY_URL = f&quot;https://web.shanbay.com/web/users/{MY_SHANBAY_USER_NAME}/zone&quot;

##### DUO ######
MY_DUOLINGO_URL = &quot;https://www.duolingo.com/profile/yihong0618&quot;

##### CICHANG ######
MY_CICHANG_URL = &quot;https://twitter.com/yihong06181/status/1359040099107897344?s=20&quot;


##### FOOD ######
MY_FOOD_STAT_HEAD = (
    &quot;| Name | First_date | Last_date | Times | \n | ---- | ---- | ---- | ---- |\n&quot;
)
MY_FOOD_STAT_TEMPLATE = &quot;| {name} | {first_date} | {last_date} | {times} |\n&quot;

##### Month Summary ######
MONTH_SUMMARY_HEAD = &quot;| Month | Number | \n | ---- | ---- | \n&quot;

MONTH_SUMMARY_STAT_TEMPLATE = &quot;| {month} | {number} |\n&quot;
</code></pre>
<p>✍️</p>
]]></content><link href="https://github.com/dululu/GitNote/issues/1"/><category term="Top"/><published>2024-01-03T18:37:05+00:00</published></entry></feed>